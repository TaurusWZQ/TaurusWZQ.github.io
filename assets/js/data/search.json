[ { "title": "C++中关于继承与访问权限的那些事", "url": "/posts/third-post/", "categories": "技术", "tags": "CPP", "date": "2022-08-12 10:00:00 +0000", "snippet": "C++中关于继承与访问权限的那些事今天我们来讨论一下在C++中关于继承与访问权限的那些事？希望能够帮助大家真正的理解基类与派生类之间访问权限的问题。当然这也是一个在面试过程过很容易被问到的一个问题。我们都知道继承（inheritance）是C++的三大特性之一。在继承的过程中会涉及很多的问题，访问权限就是其中之一。注意：在具体说明访问权限如何变化之前，首先需要明确“派生类”与“派生类对象”不能混为一谈，前者是一个type，而后者是一个实例，是一个object。接下来我们来讨论一下访问权限C++通过public，protected，private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，这三个keyword被称为成员访问限定符。在类的内部(定义类的代码内部)，无论成员被声明为public, protected还是private,都是可以互相访问的，没有访问权限的限制。在类的外部(定义类的代码之外)，只能通过对象访问成员，并且通过对象只能访问public属性的成员，不能访问private, protected 属性的成员。无论公有继承、私有和保护继承，私有成员不能被“派生类”访问，基类中的公有和保护成员能被“派生类”访问。对于公有继承，只有基类中的公有成员能被“派生类对象”访问，保护和私有成员不能被“派生类对象”访问。对于私有和保护继承，基类中的所有成员不能被‘派生类对象”访问。下面附上demo信息 （具体代码见本人github TaurusWZQ下Demo_Of_MyBlog仓库 TaurusWZQ/Demo_Of_MyBlog: Some demos of my blog (github.com)）#include&lt;iostream&gt;using namespace std;class Base{public: int a;protected: int b; private: int c;public: Base(); ~Base();};Base::Base() {}Base::~Base() {}class Derived1 : public Base { // public继承public: void xfunc1() { x = a; // 基类中的公有成员能被“派生类”访问。 } void xfunc2() { x = b; // 基类中的保护成员能被“派生类”访问。 } void xfunc3() { //x = c; // 私有成员不能被“派生类”访问 }private: int x;public: Derived1(); ~Derived1();};Derived1::Derived1() {}Derived1::~Derived1() {}class Derived2 : protected Base { // protected继承private: int y; void yfunc1() { y = a; // 基类中的公有成员能被“派生类”访问。 } void yfunc2() { y = b; // 基类中的保护成员能被“派生类”访问。 } void yfunc3() { //y = c; // 私有成员不能被“派生类”访问 }public: Derived2(); ~Derived2();};Derived2::Derived2() {}Derived2::~Derived2() {}class Derived3 : private Base { // private继承private: int z; void zfunc1() { z = a; // 基类中的公有成员能被“派生类”访问。 } void zfunc2() { z = b; // 基类中的保护成员能被“派生类”访问。 } void zfunc3() { //z = c; // 私有成员不能被“派生类”访问 }public: Derived3(); ~Derived3();};Derived3::Derived3() {}Derived3::~Derived3() {}int main() { Base parent1; parent1.a = 1; //parent1.b = 2; // 对象不能访问类中protected 属性的成员。 //parent1.c = 3; // 对象不能访问类中private 属性的成员。 Derived1 child1; child1.a = 1; //child1.b = 2; // public继承下的 派生类对象 不能访问基类 protected 属性的成员 //child1.c = 3; // public继承下的 派生类对象 不能访问基类 private 属性的成员 Derived2 child2; //child2.a = 1; // protected继承下的 派生类对象 不能访问基类 public 属性的成员 //child2.b = 2; // protected继承下的 派生类对象 不能访问基类 protected 属性的成员 //child2.c = 3; // protected继承下的 派生类对象 不能访问基类 private 属性的成员 Derived3 child3; //child3.a = 1; // private继承下的 派生类对象 不能访问基类 public 属性的成员 //child3.b = 2; // private继承下的 派生类对象 不能访问基类 protected 属性的成员 //child3.c = 3; // private继承下的 派生类对象 不能访问基类 private 属性的成员 return 0;}因此，在判断继承过程中访问权限的相关问题是，最重要的就是分清是“派生类”还是“派生类对象”。" }, { "title": "C++如何实现一个不能被继承的类", "url": "/posts/second-post/", "categories": "技术", "tags": "CPP", "date": "2022-08-08 10:00:00 +0000", "snippet": "C++如何实现一个不能被继承的类～今天我们来讨论一下在C++中 如何设计一个类，使得该类不能被继承？这是一个在面试过程过很容易被问到的一个问题。C++什么类不能被继承，首先思考派生类继承基类将会发生什么默认操作？派生类在调用自身的构造函数之前需要先调用基类的构造函数。那么我们就让这个不想被别人继承的类的构造函数无法被其派生类调用，从而能达到无法被继承的功能。最直观的解决方案显然是就是将其基类的构造函数声明为私有的，这样就可以阻止子类构造对象了。进一步思考，但是这样的话，就无法构造本身的对象了，就无法利用了。既然这样，我们又可以想定义一个静态方法来构造类和释放类。对，就这样实现它。#include&lt;iostream&gt;using namespace std;class A {public: static A * Construct(int n) { A *pa = new A; pa-&gt;num = n; cout&lt;&lt;\"num is:\"&lt;&lt;pa-&gt;num&lt;&lt;endl; return pa; } static void Destruct(A * pIntance) { delete pIntance; pIntance = NULL; }private:\tA() {}\t~A() {}public: int num;};int main() { A *f = A::Construct(9); cout&lt;&lt;f-&gt;num&lt;&lt;endl; A::Destruct(f); return 0;}按照理论分析，这样做确实可以做到防止被继承。注意：又有一个新的问题，对，就是只能在堆上创建，无法再栈上实现这个类这就是私有的构造函数的局限性。第二个方法利用友元不能被继承的特性，可以实现这样的类。主要思想，设计一个模板辅助类Base，将构造函数声明为私有的；再设计一个不能继承的类FinalClass,,将FinalClass 作为Base的友元类。将FinalClass虚继承Base。#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Base { friend T;private: Base(){ cout &lt;&lt; \"base\" &lt;&lt; endl; } ~Base(){}};class FinalClass : virtual public Base&lt;FinalClass&gt; { //一定注意 必须是虚继承public: FinalClass() { cout &lt;&lt; \"FinalClass()\" &lt;&lt; endl; }};class C:public FinalClass{public: C() {} //继承时报错，无法通过编译};int main() { FinalClass b; //B类无法被继承 //C c; return 0;}类Base的构造函数和析构函数因为是私有的，只有Base类的友元可以访问，FinalClass类在继承时将模板的参数设置为了FinalClass类，所以构造FinalClass类对象时们可以直接访问父类（Base）的构造函数。C 在调用构造函数时，不会先调用FinalClass的构造函数，而是直接调用Base的构造函数，C不是Base的友元类，所以无法访问。这样的话C就不能继承FinalClass。第三个方法当然在C++11以后，C++引入了新的关键词 new keyword final ，直接在类后面加上final关键字，就可以防止该类被继承同时如果在虚函数后面加上final关键词，该虚函数也无法被复写(overriding)#include&lt;iostream&gt;using namespace std;struct Base1 final {};//struct Derived1 : Base1 {}; //[Error] cannot derive from 'final' base 'Base1' in derived type 'Derived1'struct Base2 { virtual void f() final;};struct Derived2 : Base2 { //void f(); //[Error] overriding final function 'virtual void Base2::f()'}int main() { return 0;}" }, { "title": "真正意义上的第一篇博客！", "url": "/posts/first-post/", "categories": "随笔", "tags": "生活", "date": "2022-04-01 09:15:00 +0000", "snippet": "真正意义上的第一篇博客～现在是2022.04.01，以下是本该于2021.12.09发表的第一篇博客：经历了重重困难，终于 小王的个人博客终于即将搭建完毕！！！！感想：不知道该说些啥，断断续续的弄了半天，中间由于导师找，学院统一核酸检测，加上莫名其妙npm变量配置出问题，等等一系列问题。找了很多的帮助文档，教学贴，属实很麻烦。但是在按照教程加之自己摸索之后，在本地看到属于自己的博客之后，真的很开心，很激动，毕竟这是属于王同学自己的结晶。规划：这个博客主要用途是记录和分享自己学习经历。love&amp;share当然可能也会有一些个人碎碎念，毕竟目前的王同学还算的上一个文艺青年。同时由于王同学爱好有些广泛，因此大概率这个个人博客会略显“复杂”。愿景：希望王同学能在这条路上越走越远，希望这个博客能够长久的运营下去，希望多年后回过头来看，小王会不后悔，在某一天，做下这个决定，又希望多年后的小王会后悔，后续没有早点做下这个决定，希望未来的王同学，活成自己想要的样子To 陌生人如果真的有幸，屏幕前的你看到了我的第一篇博客，同时还看到了这里。我想说，很感谢你的到来，同时感谢你花费人生中宝贵的两分钟看了我的这篇博客，愿你人生美好！当然小概率事件，如果你认识我的话，请别告诉我，我怕社死。Anyway 2021.12.09 很特殊的日子 hello world！ 王同学敲于二零二一年十二月九日如上，又出现了一些意料之外的问题，导致这篇博客最终上线的时间变成了今天。万幸，总算是开始了。int main(){ \tcout&lt;&lt;\"hello world\"&lt;&lt;endl; return 0;}" }, { "title": "你好，世界！", "url": "/posts/hello-world/", "categories": "随笔", "tags": "生活", "date": "2022-03-26 02:34:00 +0000", "snippet": "感谢关注～这里可以放代码片段噢～//代码片段int main(){ hello world;}" } ]
